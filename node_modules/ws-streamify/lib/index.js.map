{"version":3,"sources":["../src/index.js"],"names":["DATA","ACK","END","OLD_BUFFER","global","window","lt","process","version","debug","WebSocketStream","socket","options","binaryType","_name","Math","random","toString","slice","_started","on","_send","readyState","OPEN","cork","onopen","uncork","onclose","code","msg","emit","onerror","err","onmessage","data","Buffer","Uint8Array","from","push","_cb","Error","chunks","callback","chunk","reduce","prev","next","concat","filter","b","encoding","size","type","send"],"mappings":";;;;;;;;AAAA;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;IAEQA,I,mBAAAA,I;IAAMC,G,mBAAAA,G;IAAKC,G,mBAAAA,G;;;AAEnB,IAAMC,aAAa,CAACC,OAAOC,MAAR,IAAkB,iBAAOC,EAAP,CAAUC,QAAQC,OAAlB,EAA2B,OAA3B,CAArC;;AAEA,IAAIC,QAAQ,qBAAe,cAAf,CAAZ;;IAEqBC,e;;;AACnB,2BAAaC,MAAb,EAAqBC,OAArB,EAA8B;AAAA;;AAAA,kIACtBA,OADsB;;AAG5B,0BAAOD,MAAP,EAAe,2BAAf;;AAEA,UAAKA,MAAL,GAAcA,MAAd;AACAA,WAAOE,UAAP,GAAoB,aAApB;;AAEA;AACAF,WAAOG,KAAP,GAAeH,OAAOG,KAAP,IAAgBC,KAAKC,MAAL,GAAcC,QAAd,CAAuB,EAAvB,EAA2BC,KAA3B,CAAiC,CAAjC,EAAoC,CAApC,CAA/B;;AAEA;AACA,UAAKC,QAAL,GAAgB,KAAhB;;AAEA,UAAKC,EAAL,CAAQ,QAAR,EAAkB,YAAM;AACtBX,YAAS,MAAKE,MAAL,CAAYG,KAArB;AACA,YAAKO,KAAL,CAAWnB,GAAX;AACD,KAHD;;AAKA;AACA,QAAIS,OAAOW,UAAP,KAAsBX,OAAOY,IAAjC,EAAuC,MAAKC,IAAL;;AAEvCb,WAAOc,MAAP,GAAgB,YAAM;AACpBhB,YAAS,MAAKE,MAAL,CAAYG,KAArB;AACA,YAAKY,MAAL;AACD,KAHD;;AAKAf,WAAOgB,OAAP,GAAiB,UAACC,IAAD,EAAOC,GAAP,EAAe;AAC9BpB,YAAS,MAAKE,MAAL,CAAYG,KAArB;AACA,YAAKgB,IAAL,CAAU,OAAV,EAAmBF,IAAnB,EAAyBC,GAAzB;AACD,KAHD;;AAKAlB,WAAOoB,OAAP,GAAiB,UAACC,GAAD,EAAS;AACxBvB,YAAS,MAAKE,MAAL,CAAYG,KAArB;AACA,YAAKgB,IAAL,CAAU,OAAV,EAAmBE,GAAnB;AACD,KAHD;;AAKArB,WAAOsB,SAAP,GAAmB,UAACJ,GAAD,EAAS;AAC1B,UAAIK,OAAO/B,aACP,IAAIgC,MAAJ,CAAW,IAAIC,UAAJ,CAAeP,IAAIK,IAAnB,CAAX,CADO,GACgCC,OAAOE,IAAP,CAAYR,IAAIK,IAAhB,CAD3C;AAEA,cAAQA,KAAK,CAAL,CAAR;AACE,aAAKlC,IAAL;AACE,gBAAKmB,QAAL,GAAgB,IAAhB;AACA,cAAI,CAAC,MAAKmB,IAAL,CAAUJ,KAAKhB,KAAL,CAAW,CAAX,CAAV,CAAL,EAA+B;AAC7B;AACA;AACAT,kBAAS,MAAKE,MAAL,CAAYG,KAArB;AACD;AACD;AACF,aAAKb,GAAL;AACE,gBAAKsC,GAAL;AACA;AACF,aAAKrC,GAAL;AACEO,gBAAS,MAAKE,MAAL,CAAYG,KAArB;AACA,gBAAKwB,IAAL,CAAU,IAAV;AACA;AACF;AACE,gBAAM,IAAIE,KAAJ,CAAU,0BAAV,CAAN;AAjBJ;AAmBD,KAtBD;AArC4B;AA4D7B;;;;4BAEQC,M,EAAQC,Q,EAAU;AACzBjC,YAAS,KAAKE,MAAL,CAAYG,KAArB;AACA,UAAI6B,QAAQF,OAAOG,MAAP,CAAc,UAACC,IAAD,EAAOC,IAAP;AAAA,eACxBX,OAAOY,MAAP,CAAc,CAACF,KAAKF,KAAN,EAAaG,KAAKH,KAAlB,EAAyBK,MAAzB,CAAgC,UAACC,CAAD;AAAA,iBAAOA,CAAP;AAAA,SAAhC,CAAd,CADwB;AAAA,OAAd,CAAZ;AAEA,WAAK5B,KAAL,CAAWrB,IAAX,EAAiB2C,KAAjB;AACA,WAAKJ,GAAL,GAAWG,QAAX;AACD;;;2BAEOC,K,EAAOO,Q,EAAUR,Q,EAAU;AACjCjC,YAAS,KAAKE,MAAL,CAAYG,KAArB;AACA,WAAKO,KAAL,CAAWrB,IAAX,EAAiB2C,KAAjB;AACA,WAAKJ,GAAL,GAAWG,QAAX;AACD;;;0BAEMS,I,EAAM;AACX;AACA,UAAI,KAAKhC,QAAT,EAAmB;AACjBV,cAAS,KAAKE,MAAL,CAAYG,KAArB;AACA,aAAKO,KAAL,CAAWpB,GAAX;AACD;AACF;;;0BAEM2B,I,EAAMM,I,EAAM;AACjB,UAAI,KAAKvB,MAAL,CAAYW,UAAZ,KAA2B,KAAKX,MAAL,CAAYY,IAA3C,EAAiD;AAC/C,YAAI6B,OAAOjD,aACP,IAAIgC,MAAJ,CAAW,IAAIC,UAAJ,CAAe,CAACR,IAAD,CAAf,CAAX,CADO,GAC8BO,OAAOE,IAAP,CAAY,CAACT,IAAD,CAAZ,CADzC;AAEA,aAAKjB,MAAL,CAAY0C,IAAZ,CAAiBnB,OAAOC,OAAOY,MAAP,CAAc,CAACK,IAAD,EAAOlB,IAAP,CAAd,CAAP,GAAqCkB,IAAtD;AACD;AACF;;;;;;kBA3FkB1C,e","file":"index.js","sourcesContent":["import { Duplex } from 'stream'\nimport assert from 'assert'\nimport createDebugger from 'debug'\nimport semver from 'semver'\nimport codes from './codes'\n\nconst { DATA, ACK, END } = codes\n\nconst OLD_BUFFER = !global.window && semver.lt(process.version, '6.0.0')\n\nlet debug = createDebugger('ws-streamify')\n\nexport default class WebSocketStream extends Duplex {\n  constructor (socket, options) {\n    super(options)\n\n    assert(socket, 'You must provide a socket')\n\n    this.socket = socket\n    socket.binaryType = 'arraybuffer'\n\n    // You can provide a socket name for debugging purposes. Shh, that's a secret!\n    socket._name = socket._name || Math.random().toString(36).slice(2, 7)\n\n    // When the first message is received it becomes true\n    this._started = false\n\n    this.on('finish', () => {\n      debug(`${this.socket._name}: I'm done`)\n      this._send(END)\n    })\n\n    // Buffer data until connection is established\n    if (socket.readyState !== socket.OPEN) this.cork()\n\n    socket.onopen = () => {\n      debug(`${this.socket._name}: okay, I'm ready`)\n      this.uncork()\n    }\n\n    socket.onclose = (code, msg) => {\n      debug(`${this.socket._name}: I've lost the connection`)\n      this.emit('close', code, msg)\n    }\n\n    socket.onerror = (err) => {\n      debug(`${this.socket._name}: uh oh, error!`)\n      this.emit('error', err)\n    }\n\n    socket.onmessage = (msg) => {\n      let data = OLD_BUFFER\n        ? new Buffer(new Uint8Array(msg.data)) : Buffer.from(msg.data)\n      switch (data[0]) {\n        case DATA:\n          this._started = true\n          if (!this.push(data.slice(1))) {\n            // Note that this will execute after\n            // all callbacks on 'readable' and 'data' events.\n            debug(`${this.socket._name}: ouch, I'm full...`)\n          }\n          break\n        case ACK:\n          this._cb()\n          break\n        case END:\n          debug(`${this.socket._name}: okay, bye`)\n          this.push(null)\n          break\n        default:\n          throw new Error('Unsupported message type')\n      }\n    }\n  }\n\n  _writev (chunks, callback) {\n    debug(`${this.socket._name}: hey, I'm sending you all buffered data`)\n    let chunk = chunks.reduce((prev, next) =>\n      Buffer.concat([prev.chunk, next.chunk].filter((b) => b)))\n    this._send(DATA, chunk)\n    this._cb = callback\n  }\n\n  _write (chunk, encoding, callback) {\n    debug(`${this.socket._name}: hey, I'm sending you data`)\n    this._send(DATA, chunk)\n    this._cb = callback\n  }\n\n  _read (size) {\n    // Let's not send the first ACK, since it's redundant\n    if (this._started) {\n      debug(`${this.socket._name}: go ahead, send some more`)\n      this._send(ACK)\n    }\n  }\n\n  _send (code, data) {\n    if (this.socket.readyState === this.socket.OPEN) {\n      let type = OLD_BUFFER\n        ? new Buffer(new Uint8Array([code])) : Buffer.from([code])\n      this.socket.send(data ? Buffer.concat([type, data]) : type)\n    }\n  }\n}\n"]}